**GC的常用算法**

- 标记-清除：遍历所有的GC Roots，标记所有的存活对象，然后遍历清除堆中没有标记的对象。效率低，容易产生碎片空间。
- 复制算法：将内存分为两个区间，只用其中的一个区间，当需要内存回收的时候，将存活的对象复制到空闲区间，然后将活动区间一次性回收掉。需要浪费一半的内存。
- 标记-整理：同样标记所有存活对象，移动所有存活对象到一端，然后回收末端地址以后的内存全部回收。效率低，消除了内存区域分散和内存减半的缺点。
- 分代搜集：根据对象存活的周期，Java堆被分为新生代和老年代，根据不同年代的特征，选择合适的GC收集算法。

**类加载过程**

类加载过程主要分为三个部分，**加载**、**链接**、**初始化**，链接又分为**验证**、**准备**、**解析**

- 加载：将字节码文件从不同的数据源读取到JVM内存，并映射为JVM认可的数据结构，即class对象，数据源可以是jar文件、class文件等，如果数据格式并不是ClassFile的结构，则会报ClassFormatError

- 链接：

  验证：主要为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误

  准备：创建静态变量，并为静态变量开辟内存空间

  解析：将常量池的符号引用替换为直接引用

- 初始化：为静态变量赋值，并执行静态代码块中的逻辑

**JVM内存区域划分**

JVM内存区域分为两类

线程私有区域：

- 程序计数器：每个线程都有一个私有的程序计数器，任何时间一个线程只会有一个方法正在执行，程序计数器存放的就是这个当前方法的JVM指令地址
- JVM虚拟机栈：创建线程的时候会创建线程内的虚拟机栈，栈中存放着一个个的栈帧，对应着一个个方法的调用，JVM虚拟机栈有两种操作，分别是压栈和出栈，栈帧中存放着局部变量表、方法返回值和方法的正常或异常退出的定义等等

- 本地方法栈：跟JVM虚拟机栈比较类似，只不过它支持的是Native方法

线程共有区域：

- 堆：堆是内存管理的核心区域，用来存放对象实例，几乎所有创建的对象实例都会直接分配到堆上，所以堆也是垃圾回收的主要区域，垃圾收集器会对堆有着更细的划分，最常见的就是把堆分为新生代和老年代

- 方法区：方法区主要存放类的结构信息，比如静态属性和方法等等

- 运行时常量池：运行时常量池位于方法区中，主要存放各种常量信息

**Java内存模型**

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存中进行，而不能直接读写主内存，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行

原子型：在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit，这两个字节码对应的关键字就是synchronized，可以使用它来保证方法和代码块内操作的原子性

可见性：Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的，volatile关键字提供了一个功能，就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次用之前都从主内存刷新，可以使用它来保证多线程操作时变量的可见性

有序性：在Java中，可以使用synchronized和volatile来保证多线程操作的有序性，volatile会禁止指令重排，synchronized保证同一时刻只允许一条线程操作

**sleep和wait**

sleep是Thread类中的静态方法，wait是Object类中的方法

sleep并不会释放同步锁，wait会释放同步锁

sleep可以在任何地方使用，wait只能在同步方法或同步代码块中使用

sleep必须传入时间，wait可传可不传，不传的话只有notify或notifyAll才能唤醒

**join**

join方法通常是保证线程见顺序调度的一个方法，

**Android的几种进程**

前台进程：与用户正在交互的`Activity`或`Activity`用到的`Service`

可见进程：处于暂停状态的`Activity`或者绑定在其上的`Service`，即被用户可见，但由于失去了焦点不能与用户交互

服务进程：使用`startService`启动的`Service`，虽不可见，但却是用户关心的，如音乐和下载

后台进程：已执行`onStop`而停止的进程，不是用户关心的

空进程：





























